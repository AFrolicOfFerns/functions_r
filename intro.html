<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to R Functions</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stephanie Kirmer  www.stephaniekirmer.com  @data_stephanie" />
    <meta name="date" content="2021-02-26" />
    <script src="intro_files/header-attrs-2.6/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to R Functions
## R Ladies Chicago and R Ladies East Lansing
### Stephanie Kirmer <BR> <a href="http://www.stephaniekirmer.com">www.stephaniekirmer.com</a> <BR> @<a href="http://www.twitter.com/data_stephanie">data_stephanie</a>
### February 26, 2021

---





# Overview

-   Hands on examples   
--

-   Repo: https://github.com/skirmer/functions_r   
--

-   Support Team for questions   
--


***

## Breakout Sections
  - Work through examples in small groups
  - 10 minute chunks

---
# What is a Function Anyway?

![](function_diagram.png)

???
You have one thing, and you want to have another thing, so the function is your path to get there.

---
# Why Functions?

-   Avoid repetition
-   Share code with others
-   Eventually build packages

???
Those operations you want to run in order to get from what you have to what you need are useful to others!
This framework is common to many programming languages

---
# Basic Structure


```r
myFunction &lt;- function(){
  ...
  return()
}

myFunction()
```

???
This shell is what lets R know that you intend to create a function. 
Now we need to add in the contents.

---
# Basic Structure


```r
myFunction &lt;- function(ARGUMENTS){
*  ...
  return(OUTPUT)
}

myFunction(ARGUMENTS)
```

---
# Basic Structure


```r
myFunction &lt;- function(a, b){
*  c &lt;- a*b
  return(c)
}

myFunction(a = 2,b = 4)
```


---
class: inverse

# Practice Break 1
Open possible_dog_part1.R and follow the instructions.

- Beginner: Read the sample function, and interpret what it does.
- Advanced: Take a bit of your own code and place it in a function structure. 

---
# Types
- Logical or Boolean (TRUE, FALSE, 0, 1)
- Integer (Numeric) (3, 7, 108)
- Double or Float (Numeric) (1.6645, 3.14159, 987.99)
- Character or String ("Hello", "a")
- Closure (function) (`sum()`)

More info in help: `?type` or `?mode`

Plus: list, complex, special, etc

???
Before we deep dive into these pieces, we have to make sure we understand types just a little.


---
# Arguments, or What Goes In

- Order and naming
- Defaults


```r
myFunction &lt;- function(a=1, b=1){
  ...
myFunction(a = 2,b = 4)
```

???
You can set default values for the arguments as shown
Your arguments need to observe a specific type usually

---
class: inverse

# Practice Break 2
Open possible_dog_part2.R and follow the instructions.

- Beginner: Identify the changes in the example function. Try running it, and change the arguments.
- Advanced: Add an argument to your function, and make it change the output. 

---

# Returns, or What Comes Out



```r
myFunction &lt;- function(a, b){
...
  return(c)
}
```


---
class: inverse

# Practice Break 3
Open possible_dog_part3.R and follow the instructions.

- Beginner: Identify the changes in the example function. What is it returning?
- Advanced: Add a two-element return to your function. Remember that R does not allow multi-argument returns.
---

# Guardrails: Documentation


```r
#' myFunction
#'
#' @param a Type. Description of what it represents.
#' @param b Type. Description of what it represents.
#'
#' @return Type. Description of what it represents.
#'
#' @examples
#' \dontrun{myFunction(a = 5, b = 3)}
```


---
class: inverse

# Practice Break 4
Open possible_dog_part4.R and follow the instructions.

- Beginner: Fill in the blanks in the provided function documentation.
- Advanced: Add documentation for your function, including arguments and returns.

---
# Guardrails: Type Check


```r
myFunction &lt;- function(a, b){
  if(!is.double(a)) stop("a must be a number")
  c &lt;- a*b
  return(c)
}

myFunction(a = 2,b = 4)
#myFunction(a = TRUE, b = 4)
```


---

class: inverse

# Practice Break 5
Open possible_dog_part5.R and follow the instructions.

- Beginner: Examine the type check included in the function. Pass arguments to the function that will violate it.
- Advanced: Add a type check to your function.

---

# Guardrails: Tests


```r
library(testthat)
myFunction &lt;- function(a, b){
  if(!is.numeric(a)) stop("a must be a number")
  c &lt;- a*b
  return(c)
}

test_that("Function returns correct value",
          {
            product = myFunction(a = 2,b = 4)
            expect_equal(product, 8)
            
          })
```

---
# Guardrails: Tests


```r
library(testthat)

test_that("Function returns expected error",
          {
            expect_error(myFunction(a = TRUE, b = 4))
          })
```


---

class: inverse

# Practice Break 6
Open possible_dog_part6.R and follow the instructions.

- Beginner: Fill in the argument value that will make the test pass, or change the test.
- Advanced: Write a test for your function.

---


# Environments

The function knows what exists inside itself, and what exists in the "global" environment.
Outside the function only knows what exists in the "global".
Here, a, b, and c do not exist in the world outside our function.


```r
print(environment())
print(objects())
myFunction &lt;- function(a, b){
*  c &lt;- a*b
  print(environment())
  print(objects())
  return(c)
}

myFunction(a = 2,b = 4)
```
---
# Global Environment


```r
print(environment())
```

```
## &lt;environment: R_GlobalEnv&gt;
```

```r
print(objects())
```

```
## [1] "myFunction"
```
---
# Function Environment


```r
myFunction &lt;- function(a, b){
*  c &lt;- a*b
  print(environment())
  print(objects())
  return(c)
}

myFunction(a = 2,b = 4)
```

```
## &lt;environment: 0x7fd3e967dd30&gt;
## [1] "a" "b" "c"
```

```
## [1] 8
```
---
# Exploring


```r
dplyr::top_n
```

```
## function (x, n, wt) 
## {
##     lifecycle::signal_superseded("1.0.0", "top_n()", "slice_max()")
##     wt &lt;- enquo(wt)
##     if (quo_is_missing(wt)) {
##         vars &lt;- tbl_vars(x)
##         wt_name &lt;- vars[length(vars)]
##         inform(glue("Selecting by ", wt_name))
##         wt &lt;- sym(wt_name)
##     }
##     filter(x, top_n_rank({
##         {
##             n
##         }
##     }, !!wt))
## }
## &lt;bytecode: 0x7fd3db87d590&gt;
## &lt;environment: namespace:dplyr&gt;
```

---
# Combining Functions
- A function can be an argument to another function
- This way you can chain together elements powerfully


```r
a &lt;- sum(1, 5, 3)
b &lt;- max(a, 4)
b
```

```
## [1] 9
```

```r
c &lt;- max(sum(1, 5, 3), 4)
c
```

```
## [1] 9
```


---
# Conclusion

- Functions are a way of packaging small sections of code to reuse later
- Functions accept input and return output, and contain code
- Functions can have documentation and internal tests
---
# Further Reading
* http://adv-r.had.co.nz/Functions.html
* https://r4ds.had.co.nz/functions.html
* https://nicercode.github.io/guides/functions/
* https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Writing-your-own-functions
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
